ğŸ“˜ Exercices : Listes & Pointeurs (C/C++)

10 exercices diffÃ©rents â€” Ã©noncÃ©s dÃ©taillÃ©s + corrections masquÃ©es

â¸»

ğŸ”µ Exercice 1 â€” Inversion dâ€™un tableau avec pointeurs

Ã‰crire une fonction inverse(int *tab, int n) qui inverse un tableau en utilisant uniquement des pointeurs.
	â€¢	Utilise au moins une boucle for.
	â€¢	Lâ€™inversion doit se faire sur place (pas dâ€™autre tableau).
	â€¢	Le main() doit lire la taille, allouer dynamiquement le tableau, le remplir et afficher le tableau inversÃ©.

âœ”ï¸ Correction

<details>
<summary>Clique pour afficher la correction</summary>


#include <stdio.h>
#include <stdlib.h>

void inverse(int *tab, int n) {
    int *p1 = tab;
    int *p2 = tab + n - 1;
    for (; p1 < p2; p1++, p2--) {
        int tmp = *p1;
        *p1 = *p2;
        *p2 = tmp;
    }
}

int main() {
    int n;
    printf("Taille : ");
    scanf("%d", &n);

    int *tab = malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) scanf("%d", &tab[i]);

    inverse(tab, n);

    for (int i = 0; i < n; i++) printf("%d ", tab[i]);
    free(tab);
}

</details>



â¸»

ğŸ”µ Exercice 2 â€” Trouver le minimum via pointeur

CrÃ©er une fonction int* min_ptr(int *tab, int n) qui retourne un pointeur vers la plus petite valeur.
	â€¢	Utiliser une boucle while.
	â€¢	Dans le main(), afficher lâ€™adresse et la valeur minimale.

âœ”ï¸ Correction

<details>
<summary>Afficher la correction</summary>


int* min_ptr(int *tab, int n) {
    int *min = tab;
    int i = 1;
    while (i < n) {
        if (tab[i] < *min) min = &tab[i];
        i++;
    }
    return min;
}

</details>



â¸»

ğŸ”µ Exercice 3 â€” Compter les Ã©lÃ©ments pairs

Ã‰crire une fonction int compte_pairs(int *tab, int n)
	â€¢	Utilise un doâ€¦while.
	â€¢	Retourne le nombre dâ€™Ã©lÃ©ments pairs.
	â€¢	Appeler la fonction dans le main().

âœ”ï¸ Correction

<details><summary>Afficher la correction</summary>


int compte_pairs(int *tab, int n) {
    int i = 0, c = 0;
    do {
        if (*(tab + i) % 2 == 0) c++;
        i++;
    } while (i < n);
    return c;
}

</details>



â¸»

ğŸ”µ Exercice 4 â€” Menu avec switch

Faire un programme qui utilise :
	â€¢	Un tableau dynamique.
	â€¢	Un menu switch :
	1.	Afficher le tableau
	2.	Modifier un Ã©lÃ©ment (via pointeur)
	3.	Quitter
	â€¢	Le menu tourne dans une boucle while.

âœ”ï¸ Correction

<details><summary>Afficher la correction</summary>


#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, choix = 0;
    scanf("%d", &n);
    int *t = malloc(n * sizeof(int));

    for (int i=0;i<n;i++) scanf("%d",&t[i]);

    while (choix != 3) {
        printf("1:Afficher 2:Modifier 3:Quitter\n");
        scanf("%d",&choix);
        switch (choix) {
            case 1:
                for (int i=0;i<n;i++) printf("%d ", t[i]);
                printf("\n");
                break;
            case 2: {
                int idx,val;
                scanf("%d %d",&idx,&val);
                *(t+idx) = val;
                break;
            }
        }
    }
    free(t);
}

</details>



â¸»

ğŸ”µ Exercice 5 â€” Somme via pointeurs

Ã‰crire une fonction somme(int *tab, int n)
	â€¢	Sans utiliser dâ€™index ([])
	â€¢	Seulement *(p + i) ou arithmÃ©tique de pointeurs.
	â€¢	Utiliser une boucle for.

âœ”ï¸ Correction

<details><summary>Afficher</summary>


int somme(int *tab, int n) {
    int s = 0;
    for (int i = 0; i < n; i++)
        s += *(tab + i);
    return s;
}

</details>



â¸»

ğŸ”µ Exercice 6 â€” Copier un tableau avec pointeurs

CrÃ©er une fonction copie(int *src, int *dest, int n) :
	â€¢	Copie src dans dest via pointeurs.
	â€¢	Utilise une boucle while.

âœ”ï¸ Correction

<details><summary>Afficher</summary>


void copie(int *src, int *dest, int n) {
    int i = 0;
    while (i < n) {
        *(dest + i) = *(src + i);
        i++;
    }
}

</details>



â¸»

ğŸ”µ Exercice 7 â€” Recherche dâ€™un Ã©lÃ©ment

Ã‰crire une fonction int* cherche(int *tab, int n, int x)
	â€¢	Retourne un pointeur vers la premiÃ¨re occurrence de x
	â€¢	Sinon NULL
	â€¢	Utilise une boucle for + if.

âœ”ï¸ Correction

<details><summary>Afficher</summary>


int* cherche(int *tab, int n, int x) {
    for (int i=0;i<n;i++)
        if (*(tab+i) == x)
            return tab+i;
    return NULL;
}

</details>



â¸»

ğŸ”µ Exercice 8 â€” DÃ©calage Ã  droite

CrÃ©er une fonction rotate_right(int *tab, int n) qui dÃ©cale tout le tableau vers la droite :
	â€¢	Le dernier Ã©lÃ©ment revient en premiÃ¨re position
	â€¢	Utilise un doâ€¦while

âœ”ï¸ Correction

<details><summary>Afficher</summary>


void rotate_right(int *tab, int n) {
    int last = tab[n-1];
    int i = n-1;
    do {
        tab[i] = tab[i-1];
        i--;
    } while (i > 0);
    tab[0] = last;
}

</details>



â¸»

ğŸ”µ Exercice 9 â€” CrÃ©ation dynamique et remplissage via fonction

CrÃ©er une fonction int* creer_tableau(int n) qui :
	â€¢	Alloue dynamiquement un tableau
	â€¢	Remplit le tableau avec i * 2
	â€¢	Retourne le pointeur
	â€¢	Utilise un for

âœ”ï¸ Correction

<details><summary>Afficher</summary>


int* creer_tableau(int n) {
    int *t = malloc(n * sizeof(int));
    for (int i=0;i<n;i++) t[i] = i * 2;
    return t;
}

</details>



â¸»

ğŸ”µ Exercice 10 â€” Compter les valeurs supÃ©rieures Ã  une limite

CrÃ©er une fonction int compte_sup(int *tab, int n, int limite)
	â€¢	Utilise un mÃ©lange de if / else et dâ€™un while.
	â€¢	Retourne combien de valeurs sont > limite.

âœ”ï¸ Correction

<details><summary>Afficher</summary>


int compte_sup(int *tab, int n, int limite) {
    int i = 0, c = 0;
    while (i < n) {
        if (tab[i] > limite)
            c++;
        i++;
    }
    return c;
}

</details>